---
title: XSS攻击
description: XSS（Cross-Site Scripting）跨站脚本攻击是一种常见的Web安全漏洞。
sidebar_position: 6
tags: [Web]
date: 2025-12-24
---

# XSS攻击

## 简介
跨站脚本（Cross-site scripting，同样简称为CSS, 为防止与层叠样式表Cascading Style Sheets，CSS的缩写混淆，跨站脚本攻击缩写为XSS）是一种网站应用程序的安全漏洞攻击。

XSS攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是由JavaScript编写，但实际上也可以通过Java、VBScript、LiveScript、ActiveX、Flash甚至是普通的HTML来实现。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等。

## 类型
最常见的几种分类是：
- 反射型（非持久型）XSS
- 存储型（持久型）XSS
- DOM型XSS
- 通用型XSS
- 突变型XSS

### 反射型XSS
反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。

当用户的输入或者一些用户可控参数未经处理地输出到页面上，就容易产生XSS漏洞。主要场景有以下几种：

- 将不可信数据插入到HTML标签之间时，例如`div`，`p`，`td`。
- 将不可信数据插入到HTML属性里时，例如:
```html
<div width=$INPUT></div>
```
- 将不可信数据插入到SCRIPT里时，例如:
```html
<script>var message = ” $INPUT “;</script>
```
- 还有插入到Style属性里的情况，同样具有一定的危害性，例如:
```html
<span style=” property : $INPUT ”></span>
```
- 将不可信数据插入到HTML URL里时，例如:
```html
<a href=”[http://www.abcd.com?param=](http://www.ccc.com/?param=) $INPUT ”></a>
```
- 使用富文本时，没有使用XSS规则引擎进行编码过滤。

对于以上的几个场景，若服务端或者前端没有做好防范措施，就会出现漏洞隐患。

反射型XSS通常出现在搜索等功能中，需要被攻击者点击对应的链接才能触发，且受到XSS Auditor(chrome内置的XSS保护)、NoScript等防御手段的影响较大，所以它的危害性较存储型要小。

### 存储型XSS
存储型（或HTML注入型、HTML持久型）XSS攻击最常发生在由社区内容驱动的网站或Web邮件网站，不需要特制的链接来执行。反射型XSS通常只在url中，存储型XSS黑客仅仅需要提交XSS漏洞利用代码到一个网站上其他用户可能访问的地方即可，这些地区可能是博客评论，用户评论，留言板，聊天室，HTML电子邮件，wikis，和其他的许多地方。一旦用户访问受感染的网页，就会自动触发脚本执行。

​存储型XSS漏洞的成因与反射型的根源类似，不同的是恶意代码会被保存在服务器中，导致其它用户（前端）和管理员（前后端）在访问资源时执行了恶意代码，用户访问服务器通过跨站链接返回跨站代码。

### DOM型XSS
通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。

DOM型XSS是基于文档对象模型DOM的。对于浏览器来说，DOM文档就是一份XML文档，当有了这个标准的技术之后，通过JavaScript就可以轻松的访问DOM。当确认客户端代码中有DOM型XSS漏洞时，诱使一名用户访问自己构造的URL，其利用步骤和反射型很类似，唯一的区别是构造的URL参数不用发送到服务器端，可以达到绕过Web应用防火墙WAF、躲避服务端检测的效果。

### 通用型XSS
通用型XSS，也叫UXSS或者Universal XSS，全称Universal Cross-Site Scripting。

前三种XSS攻击的是因为客户端或服务端的代码开发不严谨等问题而存在漏洞的目标网站或者应用程序。这些攻击的先决条件是访问页面存在漏洞，但是UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。

Web浏览器是正在使用的最流行的应用程序之一，当一个新漏洞被发现的时候，不管自己利用还是报告给官方都有一段不小的时间，这一过程中漏洞都可能被利用于UXSS。不仅是浏览器本身的漏洞，现在主流浏览器都支持扩展程序的安装，而众多的浏览器扩展程序可能导致带来更多的漏洞和安全问题。因为UXSS攻击不需要网站页面本身存在漏洞，同时可能访问其他安全无漏洞的页面，使得UXSS成为XSS里最危险和最具破坏性的攻击类型之一。

### 突变型XSS
突变型XSS，也叫做mXSS，全称Mutation-based Cross-Site-Scripting。

不论是服务器端或客户端的XSS过滤器，都认定过滤后的HTML源代码应该与浏览器所渲染后的HTML代码保持一致，至少不会出现很大的出入。然而，如果用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得这个认定不再成立：浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。

随后，该段攻击代码可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。这种由于HTML内容进入innerHTML后发生意外变化，而最终导致XSS的攻击流程，被称为突变型XSS。

将拼接的内容置于innerHTML这种操作在现在的WEB应用代码中十分常见，常见的WEB应用中很多都使用了innerHTML属性，这将会导致潜在的mXSS攻击。从浏览器角度来讲，mXSS对三大主流浏览器（IE，Chrome，FireFox）均有影响。

目前为止已知的mXSS种类有：
- 反引号打破属性边界导致的mXSS：该类型是最早被发现并利用的一类mXSS，于2007年被提出，随后被有效的修复。
- 未知元素中的xmlns属性所导致的mXSS：一些浏览器不支持HTML5的标记，例如IE8，会将article，aside，menu等当作是未知的HTML标签。
- CSS中反斜线转义导致的mXSS：在CSS中，允许用`\`来对字符进行转义，例如`property: 'v\61 lue'`表示`property:'value'`，其中`61`是字母`a`的ascii码（16进制）,`\`后也可以接unicode，例如`\20AC`表示`€`，正常情况下这种转义不会有问题，但是碰上innerHTML后，一些奇妙的事情就会发生。
- CSS中双引号实体或转义导致的mXSS：接上一类，依然是CSS中所存在的问题，`&quot;` `&#x22;` `&#34;`等双引号的表示形式均可导致这类问题。
- CSS属性名中的转义所导致的mXSS。
- 非HTML文档中的实体突变。
- HTML文档中的非HTML上下文的实体突变。

## XSS攻击预防
XSS攻击有两大因素：
-  攻击者提交恶意代码。
-  浏览器执行恶意代码。

### 预防DOM型XSS攻击
DOM型XSS攻击，实际上就是网站前端JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。在使用.innerHTML、.outerHTML、document.write()时要特别小心，不要把不可信的数据作为 HTML插到页面上，而应尽量使用.textContent、.setAttribute()等。

DOM中的内联事件监听器，如location、onclick、onerror、onload、onmouseover等，标签的href属性，JavaScript的eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些API，很容易产生安全隐患。

### 输入过滤
如果由前端过滤输入，然后提交到后端的话。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。

那么换一个过滤时机：后端在写入数据库前对输入进行过滤，然后把“安全的”内容返回给前端，这样是否可行？举个例子，一个正常的用户输入了`5 < 7`这个内容，在写入数据库前被转义变成了`5 $lt; 7`。问题是，在提交阶段我们并不确定内容要输出到哪里。这里的“并不确定”有两层含义：

- 用户的输入内容可能同时提供给前端和客户端，而一旦经过了escapeHTML()，客户端显示的内容就变成了乱码(`5 $lt; 7`)。
- 在前端中，不同的位置所需的编码也不同。当`5 $lt; 7`作为HTML拼接页面时，可以正常显示`5 < 7`。

所以输入过滤非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范XSS，可采用下面的两种方法

### 前端渲染把代码和数据分隔开
在前端渲染中我们明确告诉浏览器下面要设置的内容是文本（.innerText）还是属性（.setAttribute）还是样式（.style）等等，这样浏览器就不会被轻易的欺骗，执行预期外的代码了。
- Javascript：可以使用textContent或者innerText的地方尽量不使用innerHTML。
- query：可以使用text()的地方尽量不使用html()。

### 拼接HTML时对其进行转义
如果拼接HTML是必要的，就需要采用合适的转义库，对HTML模板各处插入点进行充分的转义。常用的模板引擎，如doT.js、ejs、FreeMarker等对于HTML转义通常只有一个规则，就是把`& < > " ' /`这几个字符转义掉，这样确实能起到一定的XSS防护作用，但并不完善。

## 总结
防范XSS攻击不只是服务端的任务，而是需要后端和前端共同参与的系统工程。虽然很难通过技术手段完全避免XSS攻击，但我们原则上应减少漏洞的产生。


## 参考
- [这一次，彻底理解XSS攻击](https://juejin.cn/post/6912030758404259854?searchId=20251224145251399EF67B18D7BBBE9FC5)