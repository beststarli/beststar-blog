---
title: JWT身份认证
description: JWT全称为JSON Web Token，是一种开放标准，用于在网络应用之间安全地传输声明。
sidebar_position: 5
tags: [Web]
date: 2025-12-22
---

# JWT身份认证

## 概念
**JWT** 全称为**JSON Web Token**，是一种开放标准（RFC 7519），用于在网络应用之间安全地传输声明（claims）。它是一种紧凑的、URL安全的令牌格式，常用于身份验证和授权场景，例如[单点登录SSO]()、API认证等。JWT的核心优势在于其自包含性：令牌本身包含了所有必要的信息，无需额外查询数据库即可验证。

## 基本结构
JWT由三部分组成，用点号`.`分隔，编码为Base64Url格式：
- **Header（头部）**：主要作用是用来标识，描述令牌的元数据，由两部分组成：
    - typ：type的简写，令牌类型，也就是JWT。
    - alg：Algorithm的简写，加密签名算法。一般使用HS256，JWT官网提供了12种的加密算法。
- **Payload（负载）**：也称为JWT claims，包含声明信息，例如用户ID、角色、过期时间等（通常不包含敏感数据，因为它是Base64编码的，可被解码），分为三类
    - 保留claims：主要包括iss发行者、exp过期时间、sub主题、aud用户等。
    - 公共claims：定义新创的信息，比如用户信息和其他重要信息。
    - 私有claims：用于发布者和消费者都同意以私有的方式使用的信息。
- **Signature（签名）**：使用Header中的算法对Header和Payload进行签名，确保令牌未被篡改。

JWT字符串（简化示例）：
```txt
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```
解码后：
- **Header**：`{"alg":"HS256","typ":"JWT"}`
- **Payload**: `{"sub":"1234567890","name":"John Doe","iat":1516239022"}`

## 工作原理
- **生成**：服务器根据用户信息生成JWT，并用密钥签名。
- **传输**：客户端将JWT存储在本地（如localStorage或Cookie），并在后续请求中通过HTTP头（如`Authorization: Bearer <token>`）发送。
- **验证**：服务器使用相同密钥验证签名和过期时间。如果有效，则允许访问资源。
- **过期与刷新**：JWT通常包含过期声明（exp），过期后需刷新令牌（Refresh Token）。

## 常见应用场景
- **授权**：这是使用JWT最常见的场景。用户登录后，每个后续请求都将包含JWT，允许用户访问使用该令牌允许的路由、服务和资源。单点登录SSO是当今广泛使用JWT的一项功能，因为它的开销很小，并且能够跨不同域轻松使用。
- **信息交换**：JWT是在各方之间安全传输信息比较便捷的方式。由于JWT可以签名（例如使用公钥/私钥对），因此可以确定发送者是否是在授权范围内。并且由于签名是使用标头和有效负载计算的，因此还可以验证内容是否未被篡改。

## 优缺点

| 方面       | 优点                         | 缺点                             |
| ---------- | ---------------------------- | -------------------------------- |
| **安全性** | 自包含、不可篡改（签名机制） | Payload 可解码（不适合敏感数据） |
| **性能**   | 无需服务器存储状态           | 令牌较大，增加传输开销           |
| **适用性** | 跨域、分布式系统友好         | 注销困难（需黑名单或短过期）     |

### JWT的优势
#### 无状态
JWT自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储[Session](/docs/Web开发与安全/Session与Cookie)信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。

不过，也正是由于JWT的无状态，也导致了它最大的缺点：**不可控**！

这意味着如果想要在JWT有效期内废弃一个JWT或者更改它的权限的话，并不会立即生效，通常需要等到有效期过后才可以。比如说，当用户logout的话，JWT也还有效。除非在后端增加额外的处理逻辑比如将失效的JWT存储起来，后端先验证JWT是否有效再进行处理。

#### 有效避免了CSRF攻击
[CSRF（Cross Site Request Forgery）](/docs/Web开发/CSRF攻击)一般被翻译为**跨站请求伪造**，属于网络攻击领域范围。相比于SQL脚本注入、[XSS（Cross-site scripting，跨站脚本）](/docs/Web开发/XSS攻击)等安全攻击方式，CSRF的知名度并没有它们高。但是，它的确是我们开发系统时必须要考虑的安全隐患。

跨站请求伪造，简单来说就是用你的身份去做一些不好的事情，就是发送一些对你不友好的请求，比如恶意转账。

简单举例：小李登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小李好奇地点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小李的身份给银行发送了一个转账请求，也就是通过小李的Cookie向银行发出请求。
```html
<a src="http://www.mybank.com/Transfer?bankId=11&money=10000">科学理财，年盈利率过万</a>
```
CSRF攻击需要依赖Cookie，Session认证中Cookie里的SessionID是由浏览器发送到服务端的，只要发出请求，Cookie就会被携带。借助这个特性，即使黑客无法获取我们的SessionID，只要我们误点了攻击链接，就可以达到攻击效果。

事实上并不是必须点击链接才可以达到攻击效果，很多时候，只要打开了某个页面，CSRF攻击就会发生。
```html
<img src="http://www.mybank.com/Transfer?bankId=11&money=10000" />
```

**为什么JWT不存在以上问题？**

一般情况下使用JWT的话，在我们登录成功获得JWT之后，会选择将JWT存放在localStorage中。前端的每一个请求后续都会附带上这个JWT，整个过程压根不会涉及到Cookie。因此即使点击了非法链接发送了请求到服务端，这个请求也是不会携带JWT的，所以这个请求将是非法的。

总结来说就一句话：使用JWT进行身份验证不需要依赖Cookie ，因此可以避免CSRF攻击。

不过，这样也会存在XSS攻击的风险。为了避免XSS攻击，可以选择将JWT存储在标记为httpOnly的Cookie中。但是，这样又导致了你必须自己提供CSRF保护，因此，实际项目中我们通常也不会这么做。常见的避免XSS攻击的方式是过滤掉请求中存在XSS攻击风险的可疑字符串。

#### 适合移动端应用
使用Session进行身份认证的话，需要保存一份信息在服务器端，而且这种方式会依赖到Cookie，需要Cookie保存SessionId，所以不适合移动端。但是，使用JWT进行身份认证就不会存在这种问题，因为只要JWT可以被客户端存储就能够使用，而且JWT还可以跨语言使用。

#### 单点登录SSO友好
使用Session进行身份认证的话，实现单点登录需要将用户的Session信息保存在一台电脑上，并且还会遇到常见的Cookie跨域的问题。但是，使用JWT进行认证的话，JWT被保存在客户端，不会存在这些问题。


## JWT身份认证常见问题及解决办法
### 注销登录等场景下JWT仍有效
具体的相关场景有：
- 退出登录。
- 修改密码。
- 服务端修改了某个用户具有的权限或者角色。
- 用户的帐户被封禁/删除。
- 用户被服务端强制注销。
- 用户被踢下线。

这个问题不存在于Session认证方式中，因为在Session认证方式中，遇到这种情况的话服务端删除对应的Session记录即可。但是，使用JWT认证的方式就不好解决了，JWT一旦派发出去，如果后端不增加其他处理逻辑的话，它在失效之前都是有效的。

对此有如下4种解决方案：
#### 将JWT存入内存数据库
将JWT存入数据库中，Redis内存数据库在这里是不错的选择。如果需要让某个JWT失效就直接从Redis中删除这个JWT即可。但是，这样会导致每次使用JWT发送请求都要先从数据库中查询JWT是否存在，而且违背了JWT的无状态原则。

#### 黑名单机制
和存入内存数据库的方式类似，使用内存数据库比如Redis维护一个黑名单，如果想让某个JWT失效的话就直接将这个JWT加入到黑名单即可。然后，每次使用JWT进行请求的话都会先判断这个JWT是否存在于黑名单中。

这两种方案的核心在于将有效的JWT存储起来或者将指定的JWT拉入黑名单，虽然这两种方案都违背了JWT的无状态原则，但是一般实际项目中我们通常还是会使用这两种方案。

#### 修改密钥 (Secret) 
为每个用户都创建一个专属密钥，如果想让某个JWT失效，直接修改对应用户的密钥即可。但是，这样相比于前两种引入内存数据库的方式带来的危害更大：
- 如果服务是分布式的，则每次发出新的JWT时都必须在多台机器间同步密钥。为此需要将密钥存储在数据库或其他外部服务中，这样和Session认证就没太大区别了。
- 如果用户同时在两个浏览器中打开了系统，或者在移动端也打开了系统，有一处终端的系统将账号退出，那么其他终端的系统都要重新进行登录，这是不可取的。

#### 保持令牌的短有效期并经常轮换
很简单的一种方式。但是，会导致用户登录状态不会被持久记录，而且需要用户经常登录。

对于**修改密码**后JWT仍有效的问题还是比较容易解决的。比较好的方式是：使用用户密码的哈希值对JWT进行签名，这样如果密码更改，则任何先前的令牌将自动无法验证。

### JWT的续签问题
JWT的有效期一般被建议设置的不应太长，那么JWT过期后要如何认证、如何实现动态刷新JWT，避免用户经常需要重新登录呢？

在Session认证中的一般做法是：假如Session的有效期为30分钟，如果30分钟内用户有访问，就把Session的有效期延长30分钟。

JWT认证要解决续签问题，简单总结有下面4种方案：

#### 类似于Session认证的做法
这种方案满足大部分场景。假设服务端提供的JWT有效期设置为30分钟，服务端每次进行校验时如果发现JWT的有效期马上快过期了，服务端就重新生成JWT给客户端。客户端每次请求都检查新旧JWT，如果不一致则更新本地的JWT。这种做法的问题是仅仅在快过期的时候请求才会更新JWT ,对客户端不是很友好。

#### 每次请求都返回新JWT
这种方案的思路很简单但是开销会比较大，尤其是在服务端要存储维护JWT的情况下。

#### JWT有效期设置为深夜
这种方案是一种折衷的方案，保证了大部分用户白天可以正常登录，适用于对安全性要求不高的系统。

#### 用户登录返回两个JWT
第一个是accessJWT ，它的过期时间比JWT本身的过期时间长一些比如多半个小时，另外一个是refreshJWT它的过期时间更长一点比如为一天。客户端登录后，将accessJWT和refreshJWT保存在本地，每次访问将accessJWT传给服务端。服务端校验accessJWT的有效性，如果过期的话就将refreshJWT传给服务端；如果有效的话服务端就生成新的accessJWT给客户端。否则客户端就重新登录即可。

这种方案的不足是：
- 需要客户端来配合。
- 用户注销的时候需要同时保证两个JWT都无效。
- 重新请求获取JWT的过程中会有短暂的JWT不可用的情况，不过可以通过在客户端设置定时器来解决，当accessJWT快过期时，提前通过refreshJWT获取新的accessJWT。


## 注意事项
- **安全最佳实践**：使用HTTPS传输，避免在Payload中存敏感信息；定期轮换密钥；设置合理过期时间。
- **库支持**：大多数语言有现成库，如 Node.js的`jsonwebtoken`、Python的`PyJWT`。

## 总结
JWT其中一个很重要的优势是**无状态**，但实际上我们想要在项目中合理使用JWT的话，还是需要保存JWT信息。

JWT并非Silver Bullet，也有很多缺陷，具体是选择JWT还是Session认证方案还是应结合项目的具体需求，万万不可尬吹JWT而看不起其他身份认证方案。

## 参考
- [**JWT | 一分钟掌握JWT | 概念及实例**](https://juejin.cn/post/7232550589964140602?searchId=20251222103647E3800C0D7778C886D23A)
- [**一文带你搞懂 JWT 常见概念 & 优缺点**](https://juejin.cn/post/7110044736848658445?searchId=20251222103647E3800C0D7778C886D23A#heading-1)