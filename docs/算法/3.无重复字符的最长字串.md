---
title: 3.无重复字符的最长字串
description: 给定一个字符串s ，请你找出其中不含有重复字符的最长子串的长度。
sidebar_position: 9
tags: [LeetCode,滑动窗口,中等]
date: 2026-01-19
---

# 3.无重复字符的最长字串
给定一个字符串`s` ，请你找出其中不含有重复字符的**最长子串**的长度。

示例1：
- **输入**：s = "abcabcbb"
- **输出**：3 
- **解释**：因为无重复字符的最长子串是 "abc"，所以其长度为 3。注意 "bca" 和 "cab" 也是正确答案。

示例2：
- **输入**：s = "bbbbb"
- **输出**：1
- **解释**：因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例3：
- **输入**：s = "pwwkew"
- **输出**：3
- **解释**：
  - 因为无重复字符的最长子串是`"wke"`，所以其长度为 3。
  - 请注意，你的答案必须是**子串**的长度，`"pwke"`是一个子序列，不是子串。

## 解题思路
### 个人题解
#### 1.先分割字符串片段再利用set计算每段中最大长度
理解题干要求可以知道，当一段字符串中有两个相邻字母相同时，再往后这个字符串将不再不重复，所以按这个思路可以先根据相同的相邻字母为分割线将输入的原始字符串分割为一个个片段，对每一个片段，将未遇到的字母存入set，当遍历的字母在set中存在时，则代表这个片段当前遍历的小片段再一次重复，记录当前不重复小片段的字符串长度，然后继续循环，最后输出最大值即可。

时间复杂度：O(n)
```ts
function lengthOfLongestSubstring(s: string): number {

    const maxUniqueInSegment = (seg: string): number => {
        const seen = new Set<string>()
        let left = 0
        let maxLen = 0
        for (let right = 0; right < seg.length; right++) {
            while (seen.has(seg[right])) {
                seen.delete(seg[left])
                left++
            }
            seen.add(seg[right])
            maxLen = Math.max(maxLen, right - left + 1)
        }
        return maxLen
    }

    const segments: string[] = []
    let start = 0
    for (let i = 0; i < s.length - 1; i++) {
        if (s[i] === s[i + 1]) {
            segments.push(s.slice(start, i + 1))
            start = i + 1
        }
    }
    segments.push(s.slice(start))

    if (segments.length === 0) return 0

    let maxOverall = 0;
    for (const seg of segments) {
        maxOverall = Math.max(maxOverall, maxUniqueInSegment(seg))
    }

    return maxOverall
}
```

### 官方题解

## 总结