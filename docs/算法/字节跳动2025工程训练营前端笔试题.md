---
title: 字节跳动2025工程训练营前端笔试题
description: 字节跳动2025工程训练营前端笔试3道算法题解题思路与代码。
sidebar_position: 2
tags: [字节跳动, 笔试]
date: 2025-11-08
---

# 字节跳动2025工程训练营前端笔试题

字节跳动2025工程训练营前端笔试3道算法题解题思路与代码。

## 题目一
> 构造一个由`a+b`个正整数构成的数组，满足`c`<sub>{`1`}</sub>,`c`<sub>{`2`}</sub>,....,`c`<sub>{`a+b`}</sub>恰好包含a个1和b个2，其中数组任意相邻两数的乘积是偶数，若这个数组存在则输出一个满足上述条件的数组，不存在则输出-1。

### 输入
分别输入a和b两个正整数。
```bash
2 2 
```

### 输出
符合条件的数组存在则输出一个符合条件的数组。
```bash
1 2 1 2
```
否则输出-1。
```bash
-1
```

### 思路
由于要求数组内任意相邻两数的乘积是偶数，这意味着不能有连续的两个1存在，也就是1必须被2分隔，而2可以连续，故对a的个数进行情景讨论。
- 如果`a = 0`：则无论b为多少，都满足条件。
- 如果`a >= 1`：数组内存在a个1，则至少需要`a-1`个2来分隔他们。
    - 如果`b < a-1`：那么2的个数不足以分隔所有1，不满足条件，返回-1。
    - 如果`b >= a-1`：可能满足条件，剩余的`b-(a-1)`个2可以插入数组的任何位置。
那么，本题的核心思路就是用`a-1`个2分隔a个1，构造一条`（1，2）`<sup>{`a-1`}</sup>`+1`标准链，这将用掉`a-1`个1和`a-1`个2，将剩余的`extra = b-(a-1)`个2插入到链中任何位置都不会破坏约束条件，最终的完整序列为`（1，2）`<sup>{`a-1`}</sup>` + (extra个2) + 1`。

### 代码

```typescript
import * as fs from 'fs';

function constructArray(a: number, b: number): string {
    if (a === 0) {
        return Array(b).fill(2).join(' ');
    }
    if (b < a - 1) {
        return '-1';
    }

    let arr: number[] = [];
    const extra: number = b - (a - 1);
    for (let i = 0; i < a - 1; i++) {
        arr.push(1);
        arr.push(2);
    }
    for (let i = 0; i < extra; i++) {
        arr.push(2);
    }
    if (a > 0) {
        arr.push(1);
    }
    return arr.join(' ');
}

function main(): void {
    const input: string = fs.readFileSync(0, 'utf-8').trim();
    const lines: string[] = input.split('\n');
    let idx: number = 0;
    const T: number = parseInt(lines[idx++].trim());
    for (let t = 0; t < T; t++) {
        const [a, b]: [number, number] = lines[idx++].trim().split(' ').map(Number);
        console.log(constructArray(a, b));
    }
}

main();
```


## 题目二

由于本题跳过，没有记录题目，无法解答。

## 题目三
> 对于一个n行m列矩阵，矩阵的每个格子都是正整数且初始时全部为白色，每次操作都将所有数字为x的所在格子染成红色，若x所在格子之前已经被染红过，则保持红色，一共操作q次，每次操作结束输出红色连通块的数量。

:::note 什么是连通块？
连通块，也称连通分量，是图论中的一个基本概念，指的是一个无向图中最大连通的子图。简单说，就是图中一组顶点（节点）和边（连接），满足：
- 内部连通：子图内任意两个顶点之间都有路径相连。
- 最大性：无法再添加其他顶点或边而不破坏连通性。
- 互斥：图可以分解为若干个互不连通的连通块。
:::

### 输入
首先输入矩阵的行数n和列数m，然后依次输入矩阵的每行构成，接着输入要操作的次数q，最后输入每次操作要染红的数字x。示例：
```bash
3 3
1 1 2
2 3 1
3 2 1
2
2 3
```

### 输出
每次操作后输出红色连通块的数量。
```bash
3 2
```

### 思路
本题考察DFS/BFS遍历和动态图连通性，核心目标是每次操作后高效计算红色区域的连通块数。

#### 问题建模
- 网格表示：用二维数组`grid[n][m]`存储矩阵原始正整数。
- 状态表示：用二维布尔值数组`color[n][m]`表示染色状态，初始全为false = 白，染色后为true = 红，染色状态是累积的。
- 连通定义：红色格子相邻（四方向：上、下、左、右）视为同一块。忽略对角线。
- 操作流程：
    - 读x，扫描全网格，将所有`grid[i][j] == x`的位置设置`color[i][j] = true`。
    - 计算当前`color`中的连通块数，输出。
#### 连通分量计算（DFS）
- 步骤
    - 初始化`visited[n][m]`全false。
    - 遍历每个格子`(i,j)`，如果`color[i][j] == true`且`!visited[i][j]`：
        - 从`(i,j)`启动DFS，标记整个连通块为`visited = true`。
        - 计数器`count++`（新块）。
    - 返回`count`。
- DFS实现（递归）
    - 参数：当前`(r,c)`、`n`、`m`、`color`、`visited`。
    - 标记`visited[r][c] = true`。
    - 尝试四方向`(dr,dc)：nr = r+dr, nc = c+dc`。如果`nr`,`nc`在界内、`color[nr][nc] == true`、`!visited[nr][nc]`：递归DFS`(nr,nc)`。
    - 方向数组：`[[-1,0],[1,0],[0,-1],[0,1]]`

### 代码

```typescript
import * as fs from 'fs';

type Grid = number[][];
type Color = boolean[][];

function dfs(r: number, c: number, n: number, m: number, color: Color, visited: boolean[][]): void {
    visited[r][c] = true;
    const dirs: number[][] = [[-1, 0], [1, 0], [0, -1], [0, 1]];
    for (let d of dirs) {
        let nr = r + d[0];
        let nc = c + d[1];
        if (nr >= 0 && nr < n && nc >= 0 && nc < m && color[nr][nc] && !visited[nr][nc]) {
            dfs(nr, nc, n, m, color, visited);
        }
    }
}

function countComponents(n: number, m: number, color: Color): number {
    let visited: boolean[][] = Array.from({ length: n }, () => Array(m).fill(false));
    let count = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (color[i][j] && !visited[i][j]) {
                dfs(i, j, n, m, color, visited);
                count++;
            }
        }
    }
    return count;
}

function main(): void {
    const input: string = fs.readFileSync(0, 'utf-8').trim();
    const lines: string[] = input.split('\n');
    let idx = 0;
    let [n, m]: [number, number] = lines[idx++].split(' ').map(Number);
    let grid: Grid = [];
    for (let i = 0; i < n; i++) {
        grid.push(lines[idx++].split(' ').map(Number));
    }
    let q: number = parseInt(lines[idx++]);
    let xs: number[] = lines[idx++].split(' ').map(Number);
    let color: Color = Array.from({ length: n }, () => Array(m).fill(false));
    for (let qi = 0; qi < q; qi++) {
        let x: number = xs[qi];
        for (let i = 0; i < n; i++) {
            for (let j = 0; j < m; j++) {
                if (grid[i][j] === x) {
                    color[i][j] = true;
                }
            }
        }
        let cnt: number = countComponents(n, m, color);
        console.log(cnt);
    }
}

main();
```