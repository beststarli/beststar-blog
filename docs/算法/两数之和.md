---
title: 两数之和
description: 给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值target的那两个整数，并返回它们的数组下标。
sidebar_position: 3
tags: [LeetCode]
date: 2026-01-09
---

# 两数之和
给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出**和为目标值**`target`的那**两个**整数，并返回它们的数组下标。

示例1：
- **输入**：`nums = [2,7,11,15]`，`target = 9`
- **输出**：`[0,1]`
- **解释**：因为 `nums[0] + nums[1] = 9`，所以返回 `[0, 1]`。

示例2：
- **输入**：nums = [3,2,4], target = 6
- **输出**：[1,2]

示例3：
- **输入**：nums = [3,3], target = 6
- **输出**：[0,1]

## 解题思路
### 个人题解
#### 1.暴力嵌套循环枚举
暴力解法是两层for循环查找，时间复杂度是O(n<sup>2</sup>)
```ts
function twoSum(nums: number[], target: number): number[] {
    for (let i = 0; i < nums.length; i++) {
        for (let j = i + 1; j < nums.length; j++) {
            if (nums[i] + nums[j] === target) {
                return [i, j]
            } else {
                return []
            }
        }
    }
}
```

#### 2.哈希表
```ts
function twoSum(nums: number[], target: number): number[] {
    const map = new Map<number, number>()
    for (let i = 0; i < nums.length; i++) {
        const j = target - nums[i]
        if (map.has(j)) {
            return [map.get(j)!, i]
        }
        map.set(nums[i], i)
    }
}
```

### 官方题解
与解法[2.哈希表](/docs/算法/两数之和#2哈希表)思路相同

## 思考：何时使用哈希表
当需要查询一个元素是否出现过或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

本题就需要一个集合来存放遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是**是否出现在这个集合**，那么就应想到哈希法。

因为本题不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，需要使用key, value结构来存放，key来存元素，value来存下标，那么使用map正合适。

而使用数组和set来做哈希法的局限：
- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断和数是否存在而且还要记录和数的下标位置，因为要返回和数的下标，所以set也不能用。

因此考虑另一种数据结构map ，map是一种key, value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

map用来存放访问过的元素，因为遍历数组的时候，需要记录之前遍历过哪些元素和对应的下标，这样才能找到与当前元素相匹配的数字与对应下标（也就是相加等于target）。

这道题需要给出一个元素，判断这个元素是否出现过，如果出现过，返回这个元素的下标。那么判断元素是否出现，这个元素就要作为key，所以数组中的元素作为key，有key对应的就是value，value用来存下标。所以map中的存储结构为`{key：数据元素，value：数组元素对应的下表}`。

在遍历数组的时候，只需要向map去查询是否有和目前遍历元素比配的数值，如果有，就找到的匹配对；如果没有，就把目前遍历的元素放进map中，因为map存放的就是访问过的元素。

## 总结
本题重点：
- 为什么会想到用哈希表？
- 哈希表为什么用map？
- 本题map是用来存什么的？
- map中的key和value用来存什么的？


