---
title: 560.和为k的子数组
description: 给你一个整数数组nums和一个整数k，请你统计并返回该数组中和为k的子数组的个数。子数组是数组中元素的连续非空序列。
sidebar_position: 12
tags: [LeetCode,子串,前缀和,哈希表,中等]
date: 2026-01-23
---

# 560.和为k的子数组
给你一个整数数组`nums`和一个整数`k`，请你统计并返回*该数组中和为`k`的子数组的个数*。

子数组是数组中元素的连续非空序列。

示例1：
- **输入**：nums = [1,1,1], k = 2
- **输出**：2

示例1：
- **输入**：nums = [1,2,3], k = 3
- **输出**：2

## 解题思路
### 个人题解
#### 1.两层循环遍历计算目标值
因为题干说明了子数组是一个连续非空序列，那么暴力解法很简单就可以想到，用两层循环推进计算求和，当为目标值时结果加一即可。需注意外层循环元素本身就是目标值的情况

时间复杂度：O(n²)

:::warning **耗时极长**
本方法涉及两层for循环，虽可以通过全部测试用例完成解题，但实际耗时达到了**2279ms**，超级慢！！！
![560](/img/docs/algorithm/560.png)
:::

```ts
function subarraySum(nums: number[], k: number): number {
    let result: number = 0

    for (let i = 0; i < nums.length; i++) {
        let sum = nums[i]
        let j = i + 1

        if (sum === k) result++

        while (j < nums.length) {
            sum += nums[j]
            if (sum === k) result++
            j++
        }
    }
    return result
};
```

#### 2.前缀和与哈希map
以题目[303.区域和检索-数组不可变](/docs/算法/区域和检索-数组不可变)为思路，使用前缀和与哈希map进行解题。

```ts
function subarraySum(nums: number[], k: number): number {
    let result: number = 0

    const preSum = new Map<number, number>()
    preSum.set(0, 1)

    let sum = 0
    for (const num of nums) {
        sum += num

        if (preSum.has(sum - k)) {
            result += preSum.get(sum - k)!
        }
        preSum.set(sum, (preSum.get(sum) || 0) + 1)
    }
    return result
}
```

### 官方题解

## 总结