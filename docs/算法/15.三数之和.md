---
title: 15.三数之和
description: 给你一个整数数组nums ，判断是否存在三元组[nums[i], nums[j], nums[k]]满足i!=j、i!=k且j!=k ，同时还满足nums[i]+nums[j]+nums[k]==0。请你返回所有和为0且不重复的三元组。
sidebar_position: 8
tags: [LeetCode,双指针,中等]
date: 2026-01-14
---

# 15.三数之和
给你一个整数数组`nums`，判断是否存在三元组`[nums[i], nums[j], nums[k]]`满足`i != j`、`i != k`且`j != k`，同时还满足`nums[i] + nums[j] + nums[k] == 0`。请你返回所有和为`0`且不重复的三元组。

**注意**：答案中不可以包含重复的三元组。

示例1：
- **输入**：nums = [-1,0,1,2,-1,-4]
- **输出**：[[-1,-1,2],[-1,0,1]]
- **解释**：
    - nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
    - nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
    - nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
    - 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
    - 注意，输出的顺序和三元组的顺序并不重要。

示例2：
- **输入**：nums = [0,1,1]
- **输出**：[]
- **解释**：唯一可能的三元组和不为 0 。

示例3：
- **输入**：nums = [0,0,0]
- **输出**：[[0,0,0]]
- **解释**：唯一可能的三元组和为0。

## 解题思路
### 个人题解
#### 1.双指针——内层循环盛最多水的容器
既然要寻找的是数组内三个数字和为0，那在第一层循环固定了一个数字的情况下，需要再用一层循环来确定另两个数字的和为第一个数字的相反数，于是想到了[11.盛最多水的容器](/docs/算法/15.三数之和)单层循环确定两值的思路，不过本题需要考虑去重。

时间复杂度：O(n²)
```ts
function threeSum(nums: number[]): number[][] {
    const newNums = nums.sort((a, b) => a - b)
    const result = []

    for (let i = 0; i < newNums.length; i++) {
        if (i > 0 && newNums[i] === newNums[i - 1]) continue

        const target = -newNums[i]

        let left = i + 1
        let right = newNums.length - 1

        while (left < right) {
            if (newNums[left] + newNums[right] === target) {
                result.push([newNums[i], newNums[left], newNums[right]])

                while (left < right && newNums[left] === newNums[left + 1]) left++
                while (left < right && newNums[right] === newNums[right - 1]) right--

                left++
                right--
            } else if (newNums[left] + newNums[right] < target) {
                left++
            } else {
                right--
            }
        }
    }
    return result
}
```

### 官方题解

## 总结