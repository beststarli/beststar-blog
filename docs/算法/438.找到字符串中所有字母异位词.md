---
title: 438.找到字符串中所有字母异位词
description: 给定两个字符串s和p，找到s中所有p的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
sidebar_position: 10
tags: [LeetCode,滑动窗口,中等]
date: 2026-01-22
---

# 3.无重复字符的最长字串
给定两个字符串`s`和`p`，找到`s`中所有`p`的**异位词**的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

:::secondary 字母异位词
字母异位词是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。
:::

示例1：
- **输入**：s = "cbaebabacd", p = "abc"
- **输出**：[0,6]
- **解释**：
    - 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
    - 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

示例2：
- **输入**：s = "abab", p = "ab"
- **输出**：[0,1,2]
- **解释**：
    - 起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
    - 起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
    - 起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。

## 解题思路
### 个人题解
#### 1.先剪枝再统计子串字符出现频率
通过理解题干不难发现，这样符合`p`异位词条件的子串有一个特点，就是和`p`拥有相同的字符和对应字符的出现频率而顺序无需考虑，首先想到先用一个`pMap`来统计`p`中拥有的字符和出现频率，对于输出字符串`s`，按照一定的条件将其切分成子串进行剪枝，不难发现切割条件是当遍历到`s`中出现`pMap`不存在的字符则作为边界将前部字符串切割为字串，保留当前切割位置为新子串左边界继续遍历`s`，得到预处理后的子串数组`segments`，数组中存储的每个元素都是一个对象，包含子串本身和其在`s`中的起始索引。对于`segments`再次遍历每个元素，用一个和`p`长度相同的固定大小的窗口去遍历记录每个子串中在当前窗口下出现的字符和其频率存入一个map，当这个map与`pMap`相同，则窗口移动至的索引位置即是目标值，将其填入`result`数组最终返回。

:::warning **耗时极长**
本方法涉及三层for循环，虽可以通过全部测试用例完成解题，但实际耗时达到了**2359ms**，超级慢！！！
![438](/img/docs/algorithm/438.png)
:::

时间复杂度：O(n * m)，m为`p`长度
```ts
function findAnagrams(s: string, p: string): number[] {
    if (s.length < p.length) return []

    const result: number[] = []

    const pMap = new Map<string, number>()
    for (const char of p) {
        pMap.set(char, (pMap.get(char) || 0) + 1)
    }

    const segments: { start: number; substr: string }[] = []
    let currentStart = 0
    let i = 0

    for (i = 0; i < s.length; i++) {
        if (!pMap.has(s[i])) {
            if (i > currentStart) {
                segments.push({
                    start: currentStart,
                    substr: s.substring(currentStart, i)
                });
            }
            currentStart = i + 1
        }
    }

    if (i > currentStart) {
        segments.push({
            start: currentStart,
            substr: s.substring(currentStart, i)
        });
    }
    
    for (const segment of segments) {
        const { start, substr } = segment
        const segLen = substr.length
        if (segLen < p.length) continue

        for (let j = 0; j <= segLen - p.length; j++) {
            const windowStr = substr.substring(j, j + p.length)
            const windowMap = new Map<string, number>()
            for (const char of windowStr) {
                windowMap.set(char, (windowMap.get(char) || 0) + 1)
            }

            let isMatch = true
            if (windowMap.size !== pMap.size) {
                isMatch = false
            } else {
                for (const [char, count] of pMap) {
                    if (windowMap.get(char) !== count) {
                        isMatch = false
                        break
                    }
                }
                for (const [char] of windowMap) {
                    if (!pMap.has(char)) {
                        isMatch = false
                        break
                    }
                }
            }

            if (isMatch) {
                result.push(start + j)
            }
        }
    }

    return result
}
```

### 官方题解

## 总结