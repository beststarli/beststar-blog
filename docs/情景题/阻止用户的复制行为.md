---
title: 阻止用户的复制行为
description: 阻止用户针对页面内文本内容的复制行为。
sidebar_position: 2
tags: [situation]
date: 2026-01-30
---

# 阻止用户的复制行为
在网页上阻止用户复制行为（包括选中文本、Ctrl+C、右键菜单复制、拖拽复制等）有几种常见技术手段，但一个重要事实是这些方法都无法做到100%阻止。

技术上熟练的用户可以通过开发者工具、禁用JavaScript、OCR截图、阅读模式、浏览器扩展（如Allow Copy、网页限制解除）等方式轻松绕过。

## CSS禁用文本选择
使用CSS来禁止用户选中文本，

```CSS
body {
    -webkit-user-select: none;  /* Safari */
    -moz-user-select: none;     /* Firefox */
    -ms-user-select: none;      /* IE/Edge */
    user-select: none;          /* 标准语法 */
}
```

```html
<div style='user-select: none'>这段文本不能被选中</div>
```

但用户仍可以通过开发者工具查看源码的方式来复制文本内容。

## 监听并阻止事件
通过JavaScript拦截相关键盘和剪贴板事件。
```js
document.addEventListener('copy', (e) => {
    e.preventDefault()
    alert('复制已被禁止')
})

document.addEventListener('cut', (e) => {
    e.preventDefault()
    alert('剪切已被禁止')
})

document.addEventListener('paste', (e) => {
    e.preventDefault()
    alert('粘贴已被禁止')
})
```
不过用户依然可以通过开发者工具禁用JavaScript或绕过事件监听来复制文本内容。

## 内容嵌入图片或Canvas
可以将关键内容渲染为图片或使用`<canvas>`绘制，使文本不可直接选中。
```html
<img src="text-as-image.png" alt="不可复制的文字">
```
```html
<canvas id="myCanvas"></canvas>
<script>
    const ctx = document.getElementById('myCanvas').getContext('2d')
    ctx.font = '20px Arial'
    ctx.fillText('这段文字无法复制', 10, 50)
</script>
```
但这种做法不利于[SEO](/docs/Web开发与安全/SEO)，不利于无障碍访问（屏幕阅读器无法读取），且加载慢。

## F12触发debug
当用户按下F12时，触发debug调试，让用户无法选中页面内容。
```js
<script>
(function antiDebug() {
    let devOpen = false
    const threshold = 100

    function check() {
        const start = performance.now()
        debugger
        const end = performance.now()

        if (end - start > threshold) {
            if (!devOpen) {
                devOpen = true;
                document.body.innerHTML = '<h2>检测到开发者工具，请关闭后重试。</h2>'
                // 可选：上报用户行为
                // fetch('/log-devtools', { method: 'POST' });
            }
        } else {
            devOpen = false
        }
        setTimeout(check, 1000)
    }
    check()
})()
</script>
```

## 动态文本拆分与重组
将文本内容拆分成多个DOM节点，增加复制难度。
```html
<div id="protected-text">
    <!-- 文本将被JavaScript拆分并插入 -->
</div>

<script>
    const text = "这是一段需要保护的机密内容，不能被轻易复制"
    const container = document.getElementById('protected-text')
  
    // 将每个字符用span包裹
    text.split('').forEach(char => {
        const span = document.createElement('span')
        span.textContent = char;
        span.style.display = 'inline-block' // 增加选择难度
        container.appendChild(span)
    })
</script>
```

进阶做法可以随机插入不可见字符或零宽字符。
```js
function obfuscateText(text) {
    const zeroWidthSpace = '\u200B' // 零宽空格
    return text.split('').map(char => 
        char + zeroWidthSpace.repeat(Math.floor(Math.random() * 3))
    ).join('')
}

const originalText = "保护内容"
document.getElementById('text').textContent = obfuscateText(originalText)   
```

## 使用CSS伪元素显示内容
通过CSS的`::before`或`::after`伪元素显示文本。
```html
<style>
.protected-content::before {
    content: "这段文字通过CSS生成，无法直接选中和复制"
}
</style>

<div class="protected-content"></div>
```

## 字体反爬虫
使用自定义字体文本，将字符映射关系打乱。
```css
@font-face {
    font-family: 'CustomFont'
    src: url('custom-font.woff2') format('woff2')
}

.protected-text {
    font-family: 'CustomFont'
}
```
具体做法是在字体文件中，将实际字符与显示字符的映射关系打乱，比如：
- 字符`a`在字体中实际显示为`b`
- 字符`b`显示为`c`，以此类推

也可以与后端配合，由服务器动态生成字体文件，定期更换映射关系。

## Canvas与WebGL渲染文本
```html
<canvas id="textCanvas" width="800" height="100"></canvas>
<script>
    const canvas = document.getElementById('textCanvas')
    const ctx = canvas.getContext('2d')
  
    // 设置文字样式
    ctx.font = '24px Arial'
    ctx.fillStyle = '#333'
  
    // 绘制干扰元素
    ctx.fillText('保护内容', 50, 50)
  
    // 添加噪声干扰
    for(let i = 0; i < 100; i++) {
        ctx.fillRect(
            Math.random() * 800, 
            Math.random() * 100, 
            1, 1
        )
    }
</script>
```

## SVG文本渲染
使用SVG渲染文本，增加选择难度。
```html
<svg width="400" height="100">
    <text x="10" y="30" font-family="Arial" font-size="20" fill="black" style="user-select: none;">
        这段SVG文本难以复制
    </text>
    <!-- 添加干扰路径 -->
    <path d="M10,40 L390,40" stroke="#eee" stroke-width="1"/>
</svg>
```

## 实时DOM监控与修复
监控DOM变化，防止用户通过开发者工具修改内容。
```js
const contentElement = document.getElementById('protected-content');
const originalContent = contentElement.innerHTML;

// 定时检查内容完整性
setInterval(() => {
    if (contentElement.innerHTML !== originalContent) {
        contentElement.innerHTML = originalContent
        console.log('检测到内容篡改，已恢复')
    }
}, 500)

// 使用MutationObserver更精确的监控
const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        if (mutation.type === 'childList' || mutation.type === 'characterData') {
            contentElement.innerHTML = originalContent
        }
    })
})

observer.observe(contentElement, {
    childList: true,
    characterData: true,
    subtree: true
})
```

## 综合防御策略
对于高安全要求的场景，建议采用分层防御。
```js
class ContentProtector {
    constructor() {
        this.init()
    }
    
    init() {
        this.disableSelection()
        this.bindEvents()
        this.startMonitoring()
        this.obfuscateContent()
    }
  
    disableSelection() {
        document.head.insertAdjacentHTML('beforeend', `
        <style>
            body { -webkit-user-select: none; user-select: none; }
            .protected { cursor: default; }
        </style>
        `)
    }
    
    // 绑定所有阻止事件
    bindEvents() {
        ['copy', 'cut', 'paste', 'contextmenu', 'keydown'].forEach(event => {
        document.addEventListener(event, this.preventDefault)
        })
    }
  
    preventDefault(e) {
        e.preventDefault()
        return false
    }
    
    // 启动各种监控
    startMonitoring() {
        this.monitorDevTools()
        this.monitorDOMChanges()
    }
    
    // 内容混淆处理
    obfuscateContent() {
        // ...
    }
    
    // 开发者工具检测
    monitorDevTools() {
        // ...
    }
    
    // DOM变化监控
    monitorDOMChanges() {
        // ...
    }
}

// 初始化保护
new ContentProtector()
```

## 总结
无论采用何种方式去阻止用户的复制行为，都无法做到100%限制，用户还是可以通过查看源码、截图识别、关掉JS等方式绕过复制限制。

建议：
- 只保护低价值、怕被抄袭的展示内容（如付费课程预览、内部资料预览）。
- 不要用在核心功能区（用户协议、价格表、联系方式等），会严重降低用户体验，甚至被搜索引擎惩罚。
- 重要内容靠后端控制（比如登录才能看全文）；
- 组合使用几种方法，提高门槛就好，别追求绝对安全。

毕竟前端展示的内容，就默认是能被看到的，也就能被复制。

## 参考
- **[前端怎么防止用户复制？这10种方法让你的内容更安全]**(https://juejin.cn/post/7581727073582137395?searchId=20260130204642DE113EE847C756463D5F)
- **[5种禁止用户复制的实用方案]**(https://juejin.cn/post/7527666903785586697?searchId=2026013108560875C7193AB2EB8A7A0D4C)